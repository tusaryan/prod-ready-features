L4.3

Similar to git : to look for changes inside our code, we have

Auditing : to look for changes made inside our database (DB).

Using Spring Data JPA or Hibernate Envers, we can setup auditing feature.

AuditorAware explanation Step 3.

@PrePersist : triggered just before saving the entity. So, basically this will modify the CreateBy and CreatedDate fields inside the entity

@PreUpdate : triggered just before updating the entity. So, basically this will modify the LastModifiedBy and LastModifiedDate fields inside the entity

How does this code know who making these changes/ How we are getting the user who updated? explanation -> 26:16
Due to AuditorAware Implementation which is attached with JpaAuditing by @EnableJpaAuditing(auditorAwareRef = )
which is binding us with the user who is actually making the changes. And those bound results are populated inside our DB.

Hibernate Envers -> it uses a lot of DB due to which many companies don't use it. To track the versioning of DB changes we use this. we can achieve this manually too.

How to enable auditing using Data JPA? Short explanation 43:31
Steps:
Go to your entity and extends that class with "AuditableEntity" to get the below annotation
use @EntityListeners then listen to this particular listener (AuditingEntityListener.class)
then populate all these fields like CreatedBy, CreatedDate, etc.
to populate those create a new class which implements AuditorAware interface. And inside this class pass the user who is making changes


L4.4

earlier RestTemplate was used.
RestClient : used to get the data present in other third party server. Using RestClient we can do all Rest operations like get,put,patch,delete.
It works in blocking manner (Synchronous code) i.e. unless you receive your data your code below(is blocked) it will not execute

why List<EmployeeDTO> return type is wrong 19:46
